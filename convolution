Basic Convolution layer
import numpy as np

class Conv2D:
    def __init__(self, in_channels, out_channels, kernel_size, stride=1, padding=0):
        self.stride = stride
        self.padding = padding
        
        self.kernels = np.random.randn(
            out_channels, in_channels, kernel_size, kernel_size
        )
        self.bias = np.random.randn(out_channels)

    def forward(self, x):
        # x shape: (batch_size, in_channels, height, width)
        batch_size, in_channels, h, w = x.shape
        k = self.kernels.shape[2]

        # Output size
        out_h = (h - k + 2 * self.padding) // self.stride + 1
        out_w = (w - k + 2 * self.padding) // self.stride + 1

        # Padding
        if self.padding > 0:
            x = np.pad(
                x,
                ((0, 0), (0, 0), (self.padding, self.padding), (self.padding, self.padding)),
                mode="constant"
            )

        output = np.zeros((batch_size, self.kernels.shape[0], out_h, out_w))

        for b in range(batch_size):
            for oc in range(self.kernels.shape[0]):
                for i in range(0, out_h):
                    for j in range(0, out_w):
                        region = x[
                            b,
                            :,
                            i*self.stride : i*self.stride + k,
                            j*self.stride : j*self.stride + k
                        ]
                        output[b, oc, i, j] = np.sum(
                            region * self.kernels[oc]
                        ) + self.bias[oc]

        return output
